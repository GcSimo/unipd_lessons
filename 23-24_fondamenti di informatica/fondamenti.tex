\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} % corretta sillabazione in italiano
\usepackage{geometry} % per impostare margini e layout pagina
\usepackage{amssymb} % per l'ambiente matematico
\usepackage{amsmath} % per l'ambiente matematico
\usepackage{enumitem}
\usepackage{multirow} % per celle che si espandono su più righe
\usepackage{tabularx} % per tabelle con larghezza flessibile
\usepackage{booktabs} % per linee orizzontali tabelle
\usepackage{hyperref} % per collegamenti
\usepackage{graphicx} % per immagini
\usepackage{listings} % per codice
\usepackage{xcolor} % per colori nel codice

% definizione colori
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% definizione stile
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

% utilizzo stile
\lstset{style=mystyle}


% per margini
\geometry{a4paper,left=25mm, right=25mm, bottom=25mm, top=30mm}

% per centrare testo nelle tabelleX
\renewcommand\tabularxcolumn[1]{m{#1}}

% percorso delle immagini da inserire
\graphicspath{ {./ } }

\title{Appunti di Fondamenti di Informatica}
\author{Giacomo Simonetto}
\date{Primo semetre 2023-24}

\begin{document}

% -------------------------------------- Copertina e indice ---------------------------------------
\maketitle
\begin{abstract}
	Appunti del corso di Fondamenti di Informatica della facoltà di Ingegneria Informatica dell'Università di Padova.
\end{abstract}

\newpage

\tableofcontents

\newpage

% -------------------------------------------- Storia ---------------------------------------------
\section{Storia dell'informatica}
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		fine 1800
		& Si hanno i primi tentativi di \textbf{ricerca di un linguaggio formale}. La matematica è un sistema formale
		completo? Esiste un procedimento meccanico (passo-passo, finito) per dimostrare se una proposizione sia vera
		o falsa? Il primo tentavo di \textit{"formalizzazione della matematica"} viene svolto da David Hilbert, con
		cui si scopre che la matematica possiede 23 problemi di formalizzazione chiamati \textit{"23 problemi di Hilbert"}.
		La risposta alla prima domanda risale al 1931 quando Goedel, con il \textit{"teorema di incompletezza"}
		conferma che la matematica non è un sistema formale. \\
		\midrule
		
		1936
		& Church, Turing e Kleene elaborano dei formalismi meccanici tra cui la \textbf{Macchina di Turing} e la
		\textbf{Tesi di Church-Turing} che sostiene che tutto ciò che è computabile è computabile dalla macchina di
		Turing universale. La capacità computazionale tra una macchina di Turing e un computer odierno è la stessa
		(ecceto per il fatto che la macchina di Turing prevedeva uno spazio di archiviazione illimitato), cambia
		solo la velocità computazionale. Entrambe le macchine risolvono gli stessi problemi, ovvero tutti quelli
		che si possono risolvere con un algoritmo. \\
		\midrule
		
		1943
		& Si arriva a costruire l'\textbf{ENIAC}, il primo computer (general purpose) della storia. Si programmava
		esclusivamente in binario, i circuiti si basavano sulle valvole termoioniche e occupava un palazzo di 5 piani. \\
		\midrule
		
		1948
		& Walter Brattain, John Bardeen e William Shockley creano il primo \textbf{transistor} (MOSFET) in grado di
		sommare due bit. Grazie a ciò, durante gli anni '50 si riesce a ridurre le dimensioni dei computer a un piano. \\
		\midrule
		
		1958
		& John Backus della IBM sviluppa il primo linguaggio di programmazione di alto livello \textbf{Fortran} per
		programmare uno dei computer sviluppati dall'IBM. Le novità erano quelle di poter programmare in un linguaggio
		simile all'inglese e l'introduzione delle selezioni e dei cicli. \\
		\midrule

		1966
		& Viene formulato il \textbf{Teorema di Jacopini-Bohm}: qualsiasi algoritmo è implementabile utilizzando le
		strutture fondamentali di sequenza, selezione e ripetizione. In alrre parole ha senso investire nell'informatica 
		come strumento per risolvere problemi di tipo algoritmico. \\
		\midrule
		
		1969
		& Viene inventato l'\textbf{Internet} (a carattere). \\
		\midrule

		1970-71
		& Niklaus Wirth inventa il \textbf{PASCAL}, il primo linguaggio strutturato in cui scompaiono il go-to, ma a
		differenza dei precedenti, non può essere usato per scrivere sistemi operativi. \\
		\midrule

		1970-71
		& Federico Faggin sviluppa il \textbf{primo microprocessore}. \\
		\midrule
		
		1973
		& Dennis Ritchie inventa il linguaggio \textbf{C}, simile al Pascal, ma con la possibilità di impiegarlo per
		sviluppare sistemi operativi. \\
		\midrule

		1977
		& Steve Jobs e la Apple inventano il \textbf{primo personal computer}. \\
		\midrule
		
		1979
		& Bjarne Stroustrup sviluppa il \textbf{C++}, ovvero il C con il paradigma a oggetti. \\
		\midrule
		
		1979
		& Come risposta alla Apple, la IBM crea il suo primo PC. Non credendo nei PC, non volendo perdere tempo e non
		avendo un proprio sistema operativo, la IBM si rivolge alla Microsoft (nata nel 1974) chiedendole di sviluppare
		un sistema operativo per microprocessori. La Microsoft sviluppa \textbf{MS-DOS} (Microsoft Disk Operating System)
		chiedendo 50 euro per copia (praticamente nulla). Dopo 6 anni vengono vendute 300 milioni di copie e il ricavato
		viene investito per sviluppare Windows. \\
		\midrule

		1991
		& Nasce \textbf{internet a interfaccia grafica} ed insieme ad esso c'è la necessità di avere programmi in grado di girare
		indipendentemente dal sistema operativo (Win, Mac OS, Unix). Si sviluppano le prime \textbf{Virtual Machine} in grado di 
		e codici in grado di girare su qualsiasi macchina, grazie alle Virtual Machine. \\
		\midrule
		
		1994
		& Linus Torvald pubblica la prima versione stabile del kernel \textbf{Linux} (creato nel 1991). \\
		\midrule
		
		1995
		& James Gosling nella Sun Microsystems sviluppa il linguaggio \textbf{Java}, dotato della particolarità di generare un codice
		compilato in grado di essere eseguito su qualsiasi macchina grazie alla Java Virtual Machine.
	\end{tabularx}
\end{center}

\newpage


% ------------------------------- Computer e Modello di Von Neumann -------------------------------
\section{Computer}
Per computer, o calcolatore, si intende un sistema di elaborazione e memorizzazione di informazioni che opera sotto
il controllo di un programma. È composto da hardware (parte fisica) e software (programmi e dati). I dati possono
essre di diverso tipo (immagini, testi, audio, video, \dots) e sono rappresentati elettricamente in 0 e 1.

Esistono diversi tipi di computer (workstation, smartphone, \dots) che possono svolgere diversi tipi di impieghi
(elettrodomestici, giochi, fotografie, \dots).


\section{Modello di Von Neumann}
Il modello di Von Neumann è una rappresentazione dell'archietttura di un elaboratore. Prevede la presenza di 4 blocchi:
la CPU, la memoria primaria, la memoria secondaria e i dispositivi di I/O collegati insieme grazie al BUS.

Inoltre sono presenti due diversi flussi di informazioni: quello di dati è bidirezionale (nello schema è rappresetato
dalle frecce arancioni), mentre quello degli indirizzi e dei segnali di controllo è unidirezionale con direzione CPU
\(\rightarrow\) altri blocchi (nello schema è rappresentato dalle frecce blu).

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{von-neumann-scheme.png}
\end{figure}

\subsection{Central Processing Unit o CPU}
La Central Processing Unit ha il compito di:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] individuare ed eseguire le istruzioni
	\item[-] elaborare dati attraverso la ALU (Unità Logico Aritmetica)
	\item[-] reperire dati di input e restituire dati di output
\end{itemize}

\subsubsection*{Componenti}
È costituita da tre blocchi:
\begin{center}	
	\begin{tabularx}{\textwidth}{c X}
		\textbf{Control Unit} & o \textit{CU}, gestisce l'esecuzione dei programmi e i flussi di dati \\
		\midrule
		\textbf{ALU} & o \textit{Arithmetic Logical Unit}, elabora le espressioni logiche e algebriche \\
		\midrule
		\textbf{Registri} & memorie temporanee per dati che devono essere subito elaborati:
		\begin{itemize}[topsep=3pt, itemsep=0pt]
			\item[-] l'\textbf{Accumulator}, o \textit{ACC}, che memorizza i dati elaborati o che stanno per essere elaborati dalla \textit{ALU}
			\item[-] il \textbf{Program Counter}, o \textit{PC}, che memorizza l'indirizzo di memoria dell'istruzione successiva da eseguire
			\item[-] l'\textbf{Instruction Register}, o \textit{IR}, che memorizza l'istruzione da decodificare
			\item[-] il \textbf{Memory Data Register},	o \textit{MDR}, che memorizza i dati/le istruzioni lette o che stanno per essere scritte nella memoria primaria
			\item[-] il \textbf{Memory Adress Register}, o \textit{MAR}, che memorizza l'indirizzo di memoria dell'istruzione da eseguire o del dato da utilizzare
		\end{itemize}
	\end{tabularx}
\end{center}

\subsubsection*{Funzionamento}
La CPU ha funzionamento ciclico che si divide in tre fasi. La velocità di una CPU, chiamata frequenza di clock è espressa
in cicli al secondo (dell'ordine dei GHz) ed è scandita dal \textit{Clock}. La velocità massima è dovuta ai limiti fisici
della tecnologia disponibile.

\begin{center}
	\begin{tabularx}{\textwidth}{c c X}
		\toprule
		1° fase & \textbf{fetch} &
		\begin{itemize}[topsep=3pt, itemsep=0pt, leftmargin=5pt]
			\item[-] viene letto l'indirizzo dell'istruzione da eseguire dal \textit{PC} e viene salvato nel \textit{MAR}
			\item[-] viene incrementato il \textit{PC} in modo che punti all'istruzione successiva
			\item[-] viene letta e caricata l'istruzione prima nel \textit{MDR} poi nell'\textit{IR}
		\end{itemize} \\
		\midrule
		2° fase & \textbf{decode} &
		\begin{itemize}[topsep=3pt, itemsep=0pt, leftmargin=5pt]
			\item[-] la \textit{CU} decodifica l'istruzione salvata nell'\textit{IR}
			\item[-] se necessario viene caricato nel \textit{MAR} l'indirrizzo del dato da elaborare o della posizione in cui scrivere il dato elaborato 
		\end{itemize} \\
		\midrule
		3° fase & \textbf{execute} &
		\begin{itemize}[topsep=3pt, itemsep=0pt, leftmargin=5pt]
			\item[-] viene eseguita l'istruzione:
			\item[-] se necessario viene caricato nel \textit{MDR} il dato referenziato dal \textit{MAR}
			\item[-] il dato può essere salvato nell'\textit{ACC} o impiegato in un'operazione logico-algebrica eseguita dalla \textit{ALU} 
			\item[-] il risultato viene salvato nell'\textit{ACC}
			\item[-] oppure il dato memorizzato nell'\textit{ACC} viene scritto nell'indirizzo di memoria contenuto nel \textit{MAR}
		\end{itemize} \\
		\bottomrule
	\end{tabularx}
\end{center}

\subsubsection*{Limiti e parallelismo}
I limiti della CPU sono principalmente due: la frequenza di clock e l'impossibilità di eseguire un'istruzione, finché
non viene completata quella precedente. Per superare il secondo problema si sono cercate soluzioni come il parallelismo.
Esistono due tipi di parallelismo:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] \textbf{parallelismo a livello di istruzioni}: \\ 
	detto anche pipeline o multiscalari, consiste nel suddividere il ciclo di un processore in 5 stadi (lettura, decodifica,
	recupero operandi, caricamento, esecuzione, invio risultati) e di eseguire contemporaneamente più istruzioni su stadi
	diversi. In questo modo non è necessario aspettare che l'esecuzione dell'istruzione	precedente termini per iniziare
	quella della successiva, ma è sufficiente che sia completato il primo stadio. 
	\item[-] \textbf{parallelismo a livello di processori}: \\
	consiste nell'avere più processori che lavorano contemporaneamente in grado di eseguire più istruzioni nello stesso momento.
	In base all'archietttura di distinguono in multiprocessori (se sono presenti più processori che condividono la stessa memoria)
	o multicomputer (se sono più processori, ciascuno con la propria memoria dedicata, collegati tra loro).
\end{itemize}

\subsection{Memoria primaria e secondaria}
La memoria ha il compito di memorizzare dati e programmi, sia in maniera temporanea, che permanente.

\subsubsection*{Struttura}
La memoria è composta da celle chiamate allocazioni di memoria. Ogni allocazione può contenere un preciso numero di bit.
Un bit (abbreviazione di Binary Digit) è l'unità minima di dimensione della memoria e corrisponde allo spazio occupato da 0 o 1.
Il bit è un sottomultiplo del byte, 1byte = 8bit. Il byte è l'unità minima di accesso singolo alla memoria ed è l'unità base 
per la misura della dimensione dello spazio di archiviazione.

\subsubsection*{Memoria primaria}
La memoria primaria è la più veloce delle due, ma anche la più costosa. Ne esistono due tipi:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\textbf{RAM} & o \textit{Random Access Memory}, memoria volatile, dotata della caratteristica di avere un tempo di accesso
		ad una cella indipendente dal luogo in cui essa si trova (tempo di accesso "casuale"). Viene impiegata per salvare dati 
		temporanei derivati dall'esecuzione di programmi. \\
		\midrule
		\textbf{ROM} & o \textit{Read Only Memory}, memoria permanente di sola lettura in cui vengono salvati i programmi necessari
		all'avvio della macchina, es. BIOS (\textit{Basic Input Output System}) \\
		\midrule
		\textbf{Cache} & o \textit{memoria di località}, memoria estremamente veloce che permette di memorizzare celle di memoria che
		potenzialmente potrebbero tornare utili nelle future elaborazioni. Esistono due tipi di località:
		\begin{itemize}[topsep=3pt, itemsep=0pt]
			\item[-] località temporale: accedere alla stessa cella in tempi vicini
			\item[-] località spaziale: accedere a celle limitrofe
		\end{itemize}
	\end{tabularx}
\end{center}

\subsubsection*{Memoria secondaria}
Memoria non volatile, più lenta e molto meno costosa della memoria primaria. È riservata all'archiviazione di file, dati,
programmi (tra cui anche il sistema operativo) che vengono trasferiti nella \textit{RAM} al momento dell'esecuzione.
Esistono diversi supporti di archiviazione di memoria secondaria:
\begin{itemize} [topsep=3pt, itemsep=0pt, leftmargin=5pt]
	\item[-] \textit{HDD} o disco magnetico
	\item[-] \textit{SSD} o disco a stato solido (solid state drive)
	\item[-] dischi ottici come \textit{CD}, \textit{DVD}, \textit{Blue-Ray}
	\item[-] chiavette USB
	\item[-] nastri magnetici, impiegati per l'archiviazione di documenti, sono molto lenti, ma hanno costo molto basso ed
	elevata capacità di archiviazione
\end{itemize}

\subsubsection*{Gerarchie di memoria}
Maggiore è la dimensione, minore è la velocità ed il costo.

\begin{figure}[h]
	\centering
	\includegraphics[width=7cm]{gerarchie-di-memoria.png}
\end{figure}

\subsection{Dispositivi di I/O}
Permettono l'interazione dell'essere umano con la macchina. Comprendono mouse, tastiera, touchpad, schermo, stampante, \dots
Le operazioni relative ai dispositivi i I/O sono:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\textbf{polling} & o controllo da programma, consiste nel ripetuto e periodico controllo dello stato dei dispositivi \\
		\midrule
		\textbf{interrupt} & richiama l'attenzione della CPU attraverso un'interruzione del flusso di esecuzione \\
		\midrule
		\textbf{DMA} & o \textit{Direct Memory Access}, dispositivo indipendente dalla CPU che gestisce il flusso di dati dei
		dispositivi di I/O ed alleggerisce il carico della CPU (la CPU indica solo indirizzi e dati da spostare)
	\end{tabularx}
\end{center}


\newpage

% --------------------------------------- Sistemi operativi ---------------------------------------
\section{Sistemi operativi}
\subsubsection*{Cos'è e a cosa serve}
Un sistema operativo, abbreviato \textit{SO}, è un insieme di software che fornisce all'utente una serie di comandi
e servizi per usufruire della potenza di calcolo di un elaboratore elettronico, inoltre garantisce l'operatività di
base di un elaboratore, coordinando e gestendo le risorse hardware di elaborazione e memorizzazione, le periferiche,
le risorse/attività software e facendo da interfaccia con l'utente, senza il quale quindi non sarebbe possibile
l'utilizzo del computer stesso e dei programmi. Ogni sistema operativo è legato ad uno specifico hardware.

\subsubsection*{Bootstrap}
Il bootstrap è la fase in cui viene avviato il sistema operativo, generalmente all'avvio del computer.
La procedura di bootstrap è memorizzata nella \textit{ROM}, all'avvio del computer:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] la CPU legge le istruzioni dalla ROM
	\item[-] recupera il sistema operativo dal disco (memoria secondaria)
	\item[-] carica il sistema operativo nella RAM
	\item[-] avvia l'esecuzione dei programmi che ne permettono il funzionamento
\end{itemize}

\subsubsection*{Struttura a cipolla}
Il sistema operativo è organizzato su più strati (come una cipolla), ciascuno con la caratteristica di poter interfacciarsi
soltanto con quelli più interni. Questo garantisce modularità, flessibilità e più facile manutenzione.
Gli strati, dal più interno sono:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\textbf{nucleo o core} & gestisce le risorse fisiche, comunica con l'hardware ed è scritto in linguaggio macchina \\
		\midrule
		\textbf{gestore I/O} & gestisce i dispositivi di input e output e si occupa di trasferire i dati tra le diverse
		memorie del computer \\
		\midrule
		\textbf{gestore memoria} & gestisce l'allocazione delle memorie durante l'esecuzione dei programmi \\
		\midrule
		\textbf{gestore archiviazione} & anche chiamato filesystem, organizza la struttura si archiviazione dei file \\
		\midrule
		\textbf{interfaccia utente} & permette all'utente di interagire con la macchina attraverso un'interfaccia grafica (GUI)
		o a linea di comando (CLI) \\
	\end{tabularx}
\end{center}

\subsubsection*{Comandi e linguaggi di controllo}
Ogni sistema operativo possiede un linguaggio di controllo, ovvero un insieme di comandi che permette di interfacciarsi
con il sistema operativo, eseguire operazioni o programmi, controllare le attività in corso e lo stato della macchina.
I comandi sono impartiti dall'utente attraverso il terminale o attraverso l'interazione con l'interfaccia grafica.
In Windows i comandi riprendono il vecchio sistema MS-DOS.

\newpage


\subsection{Unix - Linux}
\subsubsection*{Introduzione}
Linux è un sistema operativo sviluppato nel 1994 da Linus Torvald, basandosi su UNIX.
Unix è un sistema operativo proprietaro, Linux è la corrispettiva versione di Unix, ma open source.

\subsubsection*{Utenti e permessi}
Da sempre Linux e Unix sono sistemi multiutente, ovvero ciascun file ha un utente proprietario e ogni utente più accedere
e modificare solo dove è permesso. L'utente che non ha limitazioni è chiamato \verb|root|.

\subsubsection*{Filesystem}
Il filesystem è organizzato con una struttura ad albero capovolto, in cui la cartella, o \textit{directory}, principale,
che contiente tutti i file e le directory del sistema, è chiamata \verb|root|. Ogni elemento nel filesystem è raggiungibile
attraverso un percoso chiamato \textit{path}. Il percorso della cartella \verb|root| è \verb|\|.

I path si distinguono in:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] \textbf{percorso assoluto}: \\
	ovvero il percorso che separa la cartella \verb|root| dal file in questione, inizia con \verb|\|, ovvero il simbolo della
	cartella \verb|root|, cioè con \verb|/|, es. \verb|/user/nomeutente/home/desktop/file.txt|
	\item[-] \textbf{persorso relativo}: \\
	ovvero il percorso che separa una cartella diversa dalla \verb|root| dal file in questione, inizia con il nome della cartella
	di partenza, es. \verb|desktop/file.txt| rispetto alla \verb|home|
\end{itemize}
Il percorso per accedere alla stessa cartella è \verb|./|, quello per accedere alla cartella di livello superiore è \verb|../|

\subsubsection*{Shell o CLI}
La Shell è l'interfaccia utente a linea di comando. In Linux/Unix sono presenti diverse shell: \textit{bash}, \textit{csh},
\textit{ksb}, \textit{zsh}, in base alla distribuzione utilizzata (in Windows è quella di \textit{MS-DOS}).

I comandi della CLI si dividono in \textit{builtin}, che sono presenti di default nell'OS, ed \textit{esterni} che possono
essere installati in un secondo momento dall'utente.

In Linux/Unix sono presenti dei metacaratteri come il simbolo \verb|*|, che rappresenta una sequenza di uno o più caratteri,
e il simbolo \verb|?|, che rappresenta un singolo carattere.

Alcuni comandi di Linux/Unix sono:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\verb|cd| & change directory \\
		\verb|ls| & list files and subdirectory of the current directory \\
		\verb|cp| & copy file \\
		\verb|mv| & move or rename file \\
		\verb|rm| & remove file\\
		\verb|mkdir| & make new directory \\
		\verb|rmdir| & remove directory \\
		\verb|kill| & end process \\
		\verb|sudo| & per eseguire comandi dall'utente root \\
		\verb|man| & manuale \\
		\verb|appropos| & ricerca comandi \\
		\verb|whatis| & descrizione comando
	\end{tabularx}
\end{center}

\newpage


% ------------------------------ Rappresentazione delle informazioni ------------------------------
\section{Rappresentazione delle informazioni nei calcolatori}
In un calcolatore elettonico, le informazioni sono memorizzate ed elaborate in formato binario (0 e 1). Bisogna convertire
ciascun tipo di dato (testo, numeri, immagini, audio, video) in notazione binaria. Di seguito alcuni esempi:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		numeri naturali \(\mathbb{N}\) & rappresentazione secondo il sistema posizionale \\
		\midrule
		\multirow{2}{*}{numeri interi \(\mathbb{Z}\)} & rappresentazione modulo - segno \\
		& rappresentazione in complemento a due \\
		\midrule
		\multirow{2}{*}{numeri reali \(\mathbb{R}\)} & rappresentazione in virgola fissa \\
		& rappresentazione in virgola mobile (singola e doppia precisione) \\
		\midrule
		caratteri & tabella ASCII o Unicode
	\end{tabularx}
\end{center}

Dato che un computer può elaborare soltanto un numero finito di informazioni, mentre i numeri sono infiniti, significa che
ci sarà un valore massimo e un valore minimo rappresentabile. Inoltre viene introdotto un errore dato dal fatto che non tutti
i nmeri hanno un numero di cifre limitate (es. \(\pi\) o \(\sqrt{2}\)).

% Rappresentazione in sistema posizionale
\subsection{Rappresentazione in sistema posizionale}
Sfrutta il principio che ogni cifra possiede un peso dato dalla posizione relativa nel numero. Nel sistema decimale ogni
cifra ha, come peso, una potenza di 10, in quello binario si usano le potenze di 2.

\subsubsection*{Rappresentazione}
\begin{center}
	\begin{tabularx}{\textwidth}{l r X}
		DEC & \(234_{10}\) & \(= 2 \cdot 10 ^ 2 + 3 \cdot 10 ^ 1 + 4 \cdot 10 ^ 0 \) \\
		\midrule
		BIN & \(11101010_2\) & \(= 1 \cdot 2 ^ 7 + 1 \cdot 2 ^ 6 + 1 \cdot 2 ^ 5 + 0 \cdot 2 ^ 4 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 2 + 1 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0\) \\
		\midrule
		base \(b\) & num con \(n\) cifre &
		\[a_{n-1} a_{n-2} \dots a_0 = \sum_{k = 0}^{n-1} a_k \cdot b ^ k \quad \text{ con }
		\begin{aligned}
			a_k &= k \text{-esima cifra} \\
			b^k &= \text{peso della } k \text{-esima cifra}
		\end{aligned}\]
	\end{tabularx}
\end{center}

\subsubsection*{Valori rappresentabili}
Il range di valori rappresentabili è \(\left[ 0, 2^n - 1 \right]\).

\subsubsection*{Conversione decimale - binario}
Per eseguire la conversione dal sistema decimale a quello binario, bisogna usare l'algoritmo di conversione:
\begin{lstlisting}[language=Java]
while (numero != 0)
	resto[i] = numero % base
	numero = numero / base
\end{lstlisting}

Il numero converito si ottiene giustapponendo i resti ottenuti al contrario, in modo che l'ultimo resto è la cifra più
significativa e il primo resto è quella meno significativa.

\subsubsection*{Conversione binario - decimale}
Per convertire un numero dal sistema binario a quello decimale, basta associare ciascuna cifra al suo peso in potenza
di 2 e sommare i valori ottenuti.
\begin{align*}
	11101010_2 &=  1 \cdot 2 ^ 7 + 1 \cdot 2 ^ 6 + 1 \cdot 2 ^ 5 + 0 \cdot 2 ^ 4 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 2 + 1 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0 \\
	&=  1 \cdot 128 + 1 \cdot 64 + 1 \cdot 32 + 0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 0 \cdot 1 \\
	&= 128 + 64 + 32 + 8 + 2 \\
	&= 234_{10}
\end{align*}

\newpage


% Rappresentazione in modulo - segno
\subsection{Rappresentazione in modulo - segno}
Con il sistema posizionale non è possibile rappresentare valori negativi, per cui viene introdotta la rappresentazione
modulo-segno. Tale sistema prevede di riservare il primo bit al segno del numero ed i restanti per il modulo rappresentato
con il sistema decimale. 

\subsubsection*{Rappresentazione}
\begin{center}
	\begin{tabularx}{\textwidth}{l X}
		num \(\geq 0\) & \(+12_{10} = +1 \cdot 1100_2 = 0 + 1100_2 = 01100_{2MS}\) \\
		\midrule
		num \(< 0\) & \(-12_{10} = -1 \cdot 1100_2 = 1 + 1100_2 = 11100_{2MS}\)
	\end{tabularx}
\end{center}

\subsubsection*{Valori rappresentabili}
Il range di valori rappresentabili è \(\left[- \left(2^{n - 1} - 1\right); + \left(2^{n - 1} - 1\right) \right]\).
Si osserva che lo \(0_{10}\) possiede due rappresentazioni: \(1 0000_{2MS}\) e \(0 0000_{2MS}\)  per \(n = 4\).
		
\subsubsection*{Conversioni}
Per le conversioni da sistema decimale a binario e viceversa si ricorre al procedimento illustrato nel sistema porizionale,
con l'unica particolarità di avere uno \verb|0| se il numero è positivo ed un \verb|1| se il numero è negativo.

\subsubsection*{Criticità}
Questo sistema di rappresentazione non viene utilizzato in quanto l'algoritmo per eseguire somme (e sottrazioni) è poco
efficiente e complesso.

\newpage


% Rappresentazione in complemento a 2
\subsection{Rappresentazione in complemento a 2}
Con la rappresentazione in complemento a 2 è possibile rappresentare numeri interi positivi e negativi, eliminando la
doppia rappresentazione dello zero e semplificando l'algoritmo di somma (e differenza), avendo sempre i positivi e lo
0 che inziano per \verb|0| e i negativi che iniziano per \verb|1|.

\subsubsection*{Rappresentazione}
\begin{center}
	\begin{tabularx}{\textwidth}{l X}
		num \(\geq 0\) & \(+12_{10} = 0 + 1100_2 = 01100_{C2}\) \\
		\midrule
		num \(< 0\) & \(-12_{10} = 10100_{C2} \quad \rightarrow \quad -12 + 32 = 20_{10} = 10100_{2}\)
	\end{tabularx}
\end{center}

\subsubsection*{Valori rappresentabili}
Il range di valori rappresentabili è \(\left[ - 2^{n - 1}; 2^{n - 1} - 1 \right]\).

\subsubsection*{Conversione decimale - binario}
Per i numeri positivi, compreso lo 0, si impiega il classico sistema posizionale (aggiungendo uno \verb|0| davanti al
numero per il segno), mentre per i numeri negativi è necessario:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[1.] sommare \(2^n\) con \(n\) numero di cifre in binario in modo da rendere il numero positivo
	\item[2.] convertire il risultato secondo il sistema posizionale (se i conti sono giusti il numero inizierà per \verb|1|)
\end{itemize}
\begin{align*}
	+12_{10} &= 0 + 1100_2 = 01100_{C2} \\
	-12_{10} &\rightarrow -12 + 2^5 = 20_{10} = 10100_{2} \\
	-12_{10} &= 11100_{C2}
\end{align*}

In alternativa se il numero è negativo
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[1.] convertire il modulo secondo il sistema posizionale
	\item[2.] aggiungerci uno \verb|0| davanti
	\item[3.] invertire le cifre (gli \verb|0| diventano \verb|1| e gli \verb|1| diventano \verb|0|)
	\item[4.] sommarci 1 (se i conti sono giusti il numero inizierà per \verb|1|)
\end{itemize}
\begin{align*}
	-12_{10} &\rightarrow 1100_{2} \rightarrow 00011 \rightarrow 10011 \rightarrow 10011 + 1 \rightarrow 10100 \\
	-12_{10} &= 10100_{C2}
\end{align*}

\subsubsection*{Conversione binario - decimale}
Per i numeri che iniziano per \verb|0| basta eseguire la conversione per sistema posizionale, per quelli che inizano con
\verb|1| bisogna converire il numero secondo il sistema posizionale e toglierci \(2^n\) con \(n =\) cifre del numero.

\begin{align*}
	01100_{C2} &= 0 \cdot 2 ^ 4 + 1 \cdot 2 ^ 3 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0 \\
	&= 8 + 4 \\
	&= 12_{10}
\end{align*}
\begin{align*}
	10100_{C2} &= 1 \cdot 2 ^ 4 +  0 \cdot 2 ^ 3 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0 \quad - 2 ^ 5\\
	&= 16 + 4 \quad - 32 \\
	&= 28 - 32 \\
	&= -12_{10}
\end{align*}

\newpage

% Rappresentazione in virgola fissa
\subsection{Rappresentazione in virgola fissa}
La rappresentazione in virgola fissa riprende il principio del sistema posizionale, usando potenze con esponenti negativi
per le cifre dopo la virgola.

\subsubsection*{Rappresentazione}
\begin{center}
	\begin{tabularx}{\textwidth}{l r X}
		DEC & \(234,56_{10}\) & \(= 2 \cdot 10 ^ 2 + 3 \cdot 10 ^ 1 + 4 \cdot 10 ^ 0 + 5 \cdot 10 ^ -1 + 6 \cdot 10 ^ -2\) \\
		\midrule
		\multirow{2}{*}{BIN} & \multirow{2}{*}{\(11101010,1001_2\)} & \(= 1 \cdot 2 ^ 7 + 1 \cdot 2 ^ 6 + 1 \cdot 2 ^ 5 + 0 \cdot 2 ^ 4 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 2 + 1 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0 +\) \\
		& & \(+ 1 \cdot 2 ^ -1 + 0 \cdot 2 ^ -2 + 0 \cdot 2 ^ -3 + 1 \cdot 2 ^ -3\) \\
		\midrule
		base \(b\) & num con \(n,m\) cifre &
		\[a_n a_{n-1} \dots a_0, a_1 a_2 \dots a_{m}  = \sum_{k = 0}^{n} a_k \cdot b ^ k + \sum_{k=1}^{m} a_k \cdot b ^ {-k}\]
		con \(a_k = k\)-esima cifra, \(b^k, b^{-k} =\)peso della \(k\)-esima cifra
	\end{tabularx}
\end{center}

\subsubsection*{Valori rappresentabili}
Il range di valori rappresentabili è \(0 + \left[ 2^{-m}, 2^n - 1 \right]\), con \(n\) cifre intere, \(m\) cifre decimali.

\subsubsection*{Conversione decimale - binario}
Per eseguire la conversione dal sistema decimale a quello binario, è necessario dividere la parte intera da quella dopo
la virgola. Per la prima basta convertirla con l'algoritmo visto per il sistema posizionale, mentre per la parte decimale
è necessario applicare il seguente "algoritmo":
\begin{lstlisting}[language=Java]
while (numero != 0)
	parteIntera[i] = parteIntera di numero 
	numero = numero * base
\end{lstlisting}
Per ottenere il numero convertito è necessario prendere le parti intere in ordine (senza invertirli). Si osserva che il
risultato potrebbe essere un numero illimitato.

\subsubsection*{Conversione binario - decimale}
Per convertire un numero dal sistema binario a quello decimale, basta associare ciascuna cifra al suo peso in potenza
di 2 e sommare i valori ottenuti.
\begin{align*}
	11101010,1001_2 &= 1 \cdot 2 ^ 7 + 1 \cdot 2 ^ 6 + 1 \cdot 2 ^ 5 + 0 \cdot 2 ^ 4 + 1 \cdot 2 ^ 3 + 0 \cdot 2 ^ 2 + 1 \cdot 2 ^ 1 + 0 \cdot 2 ^ 0 + \\
	&\;\;\;\; + 1 \cdot 2 ^{-1} + 0 \cdot 2 ^{-2} + 0 \cdot 2 ^{-3} + 1 \cdot 2 ^{-4} \\
	&=  1 \cdot 128 + 1 \cdot 64 + 1 \cdot 32 + 0 \cdot 16 + 1 \cdot 8 + 0 \cdot 4 + 1 \cdot 2 + 0 \cdot 1 + \\
	&\;\;\;\; + 1 \cdot \frac{1}{2} + 0 \cdot \frac{1}{4} + 0 \cdot \frac{1}{8} + 1 \cdot \frac{1}{16} \\
	&= 128 + 64 + 32 + 8 + 2 + 0,5 + 0,0625\\
	&= 234,5625_{10} \\
	&\approx 234,56_{10}
\end{align*}

\subsubsection*{Criticità}
Non tutti i numeri sono rappresentabili in un numero finito di cifre. Alcuni numeri che nel sistema decimale hanno un
numero finito di cifre, nel sistema binario potrebbero essere illimitati, per cui la loro rappresentazione potrebbe
essere un'approssimazione. Inoltre è poco efficiente in quando per rappresentare numeri molto grandi, la parte decimale
sarebbe poco significativa e i bit riservati a tale parte si potrebbero usare per la parte intera. Viceversa per numeri
prossimi allo 0.

\newpage

% Rappresentazione in virgola mobile
\subsection{Rappresentazione in virgola mobile}
Utilizza la notazione esponenziale con mantissa ed esponente che permette maggiore flessibilità per numeri molto grandi
e numeri prossimi allo 0. Lo standard \textit{IEEE 754} prevede due rappresentazioni: a singola e a doppia precisione.

\subsubsection*{Rappresentazione}
\begin{center}
	\begin{tabularx}{\textwidth}{l r X}
		DEC & \(234,56_{10}\) & \(= 0,23456 \cdot 10 ^ 4 \) \\
		\midrule
		BIN & \(11101010,1001_2\) & \(= 0,111010101001 \cdot 2 ^ 8\)
	\end{tabularx}
\end{center}

\subsubsection*{Suddivisione in bit}
Per lo standard a singola precisione, la suddivione dei bit in segno mantissa esponente 1 + 23 + 8. \\
Per lo standard a doppia precisione, la suddivione dei bit in segno mantissa esponente 1 + 52 + 11.

\subsubsection*{Valori rappresentabili}
Il range di valori rappresentabili, sia a singola che a doppia precisione, sono molto ampi (\(\pm 2^{127}\) a singola),
la precisione che si valuta è la distanza tra due numeri binari con la virgola adiacenti.

Per la singola precisione, avere 23 bit di mantissa, significa che posso suddividere l'intervallo da \(0,0\dots1 \cdot 2^n,
0,1\dots1 \cdot 2^n\) in \(2^{23}\) parti. Queste parti saranno èiù fitte per esponenti bassi e meno fitte per esponenti
alti.

Per lo standard a singola precisione si ha che la differenza tra due numeri adiacenti \(\delta = 2^{23} \cdot 2^E\), dove
\(E\) è l'esponente binario dei numeri da rappresentare che varia da \(\left[ -127, +128\right]\).

Per lo standard a singola precisione si ha che la differenza tra due numeri adiacenti \(\delta = 2^{52} \cdot 2^E\), dove
\(E\) è l'esponente binario dei numeri da rappresentare che varia da \(\left[ -1023, +1024\right]\).

\subsection*{Valori limite}
Alcune combinazioni di mantissa ed esponente sono catalogate per valori particolari come:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[\(0\): ] esponente minimo, mantissa 0
	\item[\(\infty\): ] esponente massimo, mantissa 0
	\item[NaN: ] esponente massimo, mantissa 1 (\textit{Not A Number}) 
\end{itemize}

\subsubsection*{Criticità}
Non tutti i numeri sono rappresentabili con un numero finito di cifre, ma vengono introdotte approssimazioni, come nel
caso di 4,35 (che ha una rappresentazione binaria illimitata). Per questo motivo, quando si fanno confronti tra valori
in virgola mobile è necessario introdurre un errore entro cui due numeri sono uguali.

Inoltre nel caso in cui si lavora con numeri molto grandi a cui vengono sommati numeri molto piccoli, si rischia di
non avere abbastanza precisione per eseguire correttamente la somma, rischiando di perdere il valore dell'addendo minore.
Questo avviene soprattutto quando l'addendo più piccolo è minore della precisione del numero più grande.

\subsection{Base esadecimale e ottale}
Le rappresentazioni in basi diverse da quella binaria o decimale si comportano allo stesso modo. Nella base ottale vengono
impiegati i simboli da 0 a 7 (8 simboli), in quella esadecimale da 0 a F (15 simboli).

\subsection{ASCII e UNICODE}
Il codice ASCII e quello UNICODE sono sistemi che associano ad ogni simbolo (carattere) un numero senza segno. Nello
standard ASCII vengono riservati 7 bit per ogni carattere per un massimo di 128 simboli (poi estesi a 256 con l'extended ASCII),
mentre per l'UNICODE si impiegano 2 byte per un massimo di 65536 simboli rappresentabili. \\
Il sistema UNICODE, ad oggi il più usato, comprende il vecchio codice ASCII.

\newpage

% ---------------------------------- Linguaggi di programmazione ----------------------------------
\section{Introduzione alla programmazione}

\subsection{Algoritmo}
Un algoritmo è un metodo di risoluzione di un problema che:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] deve essere eseguibile
	\item[-] non deve essere ambiguo
	\item[-] deve concludersi in un numero finito di passi
\end{itemize}

\subsection{Computational Thinking}
Per computational thinking, o pensiero computazionale, si intende l'insieme delle abilità che permettono di astrarre
il problema e tradurlo in algoritmo. Comprende le tecniche di astrazione/risoluzione di problemi algoritmici tra
cui la decomposizione di problemi complessi e la modularità.

\subsection{Programmazione}
Per programmazione si intende il processo di progettazione e codifica di programmi per calcolatori. \\
Per programma si intende l'implementazione di algoritmi in un qualche linguaggio per calcolatore. \\
Un programma è corretto se possiede correttezza semantica, correttezza sintattica e correttezza logica. \\
Il teorema di Jacopini-Bohm sostiene che un programma/algoritmo è composto da istruzioni imperative, istruzioni condizionali,
o decisioni, e iterazioni, o cicli.

\subsection{Linguaggi di programmazione}
Per linguaggio di programmazione si intende un sistema per la scrittura di programmi/algortimi eseguibili da un calcolatore.
Deve essere rigoroso e non avere ambiguità.

\subsubsection*{Linguaggio macchina}
Il linguaggio macchina è il primo esempio di linguaggio di programmazione, è diverso per ogni tipo di processore e le
istruzioni sono composte da sequenze di bit. Le istruzioni si dividono in tre categorie:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] trasferimento dati (es. \verb|LOAD| per registri, \verb|STORE| per memorie)
	\item[-] operazioni aritmetiche e logiche (es. \verb|ADD|, \verb|SUB|, \verb|MUL|, \verb|DIV|, \verb|AND|, \verb|OR|, \verb|NOT|)
	\item[-] salti (es. \verb|JUMP|, \verb|JZ| se \verb|== 0|, \verb|JGZ| se \verb|> 0|)
\end{itemize}

\subsubsection*{Linguaggi assembly e di basso livello}
Permettono di scrivrere codice macchina attraverso codici mnemonici più simili al linguaggio umano, per cui più semplice
da utilizzare. C'è una corrispondenza biunivoca tra l'instruction set del processore e il linguaggio assembly (o basso
livello), per cui è diverso per ogni processore. Le istruzioni sono convertite in linguaggio macchina da un assembler.
Rimane sempre il problema della portabilità.

\subsubsection*{Linguaggi di alto livello}
Sono linguaggi formali (artificiali), espressivi, non ambigui, efficienti e molto più leggibili e versatili dei precedenti
in quanto simili al linguaggio parlato. Posseggono precise regole grammaticali (lessicali, sintattiche e semantiche) definite
dalla notazione EBNF (Extended Backus-Naur form). Sono convertiti in linguaggio macchina da un compilatore. Si dividono in:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] \textbf{linguaggi compilati}: \\
	il programma (indipendente dalla CPU) è convertito in codice eseguibile (dipendente dalla CPU) da un compilatore,
	garantisce alta velocità, ma bassa portabilità
	\item[-] \textbf{linguaggi interpretati}: \\
	le istruzioni tradotte in linguaggio macchina da un interprete durante l'esecuzione, garantisce alta portabilità,
	ma lenta velocità di esecuzione
\end{itemize}

\subsubsection*{Breve storia sui linguaggi di programmazione}
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		anni 50
		& primi linguaggi di programmazione ad alto livello (\verb|FORTRAN|, \verb|BASIC|, \verb|COBOL|), viene coniato il
		termine \textit{spaghetti code} per l'inappropriato uso delle istruzioni di salto (\verb|GOTO|) \\
		\midrule
		
		anni 60-70
		& programmazione strutturata con istruzioni imperative, selezioni e iterazioni, come previsto dal teorema di
		Jacopini-Bohm (1966), compaiono nuovi linguaggi strutturati \verb|PASCAL| (1968) e \verb|C| (1970-75) \\
		\midrule

		anni 80-90
		& si sviluppa il paradigma di programmazione ad oggetti con nuovi linguaggi come \verb|C++| (1979) e \verb|Java|
		(1991) in grado di supportare la creazione di classi e oggetti
	\end{tabularx}
\end{center}


% --------------------------------------------- Java ----------------------------------------------
\section{Java}
\subsection{Introduzione}
\verb|Java| è un linguaggio di programmazione ad oggetti, sviluppato da James Gosling nel 1995. La sua particolarità è di
essere un linguaggio fortemente tipizzato come il \verb|C| o \verb|C++|, ma più semplice e flessibile in quanto la gestione
della memoria non deve essere fatta dal programmatore e presenta librerie standard molto ricche.

Non è né un linguaggio interpretato, né un linguaggio compilato. Un file con un programma scritto in java si presenta con
l'estensione \verb|.java|, viene pseudocompilato da un compilatore java e convertito in un file con estensione \verb|.bytecode|.
Il file bytecode può essere eseguito da un computer con installata la Java Virtual Machine, o JVM, ovvero l'ambiente di
esecuzione che funge da interprete del file bytecode.

Per questo motivo è più veloce di un linguaggio interpretato, ma meno veloce di uno compilato e meno portabile di uno
interpretato, ma più portabile di uno compilato.

Per compilare un file java si utilizza il comando \verb|javac NomeFile.java|, per eseguire un file bytecode si usa
\verb|java NomeFile|


\subsection{Struttura di un programma}
Un programma in java è composto da diversi elementi (introduzione):
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\textbf{classi}
		& contenitori di metodi e variabili, possono essere eseguibili se contengono un metodo \verb|main|, come fabbriche
		di oggetti o entrambe (anche se poco raccomandabile); le classi sono organizzabili in pacchetti e sono importabili
		in file diversi da quello in cui sono implementate attraverso la parola chiave \verb|import| \\
		\midrule
		
		\textbf{metodi}
		& sequenze di istruzioni, chiamati anche funzioni o procedure in altri linguaggi; devono necessariamente essere
		contenuti in una classe, il metodo principale \verb|main| viene eseguito all'avvio del programma \\
		\midrule

		\textbf{variabili}
		& spazi di memoria riservati per memorizzare dati, ogni variabile può contenere solo un particolare tipo di dato
		es. \verb|int|, \verb|double|, \verb|char|, \dots il valore di una variabile può essere modificato nel corso
		dell'esecuzione del programma \\
		\midrule
		
		\textbf{costanti}
		& spazi di memoria riservati per memorizzare valori che rimangono costanti per tutta la durata del programma,
		come le variabili, anche le costanti sono tipizzate \\
		\midrule
		
		\textbf{literals}
		& insieme di valori numerici e stringhe di testo che sono contenuti nel programma \\
		\midrule
		
		\textbf{oggetti}
		& istanze di una classe, sono variabili particolari in grado di avere dei metodi in grado di compiere operazioni
		su di esse, es. stringhe, array, strutture dati \\
		\midrule
		
		\textbf{commenti}
		& parti di testo che vengono ignorate dal compilatore al momento della compilazione, si utilizzano per descrivere
		la funzione di una determinata parte di codice \\
		\midrule

		\textbf{strutture logiche}
		& insieme di costrutti che permettono di compiere selezioni e iterazioni, es. \verb|if|, \verb|else|, \verb|while|,
		\verb|for|, \dots \\
		\midrule

		\textbf{parole chiave}
		& insieme di parole riservate con una funzione logica ben precisa, es. le strutture logiche, tipi delle variabili,
		\verb|import|, \verb|final|, \verb|private|, \verb|public|, \verb|new| \dots
	\end{tabularx}
\end{center}


\subsection{Variabili}
Una variabile è uno spazio di memoria riservato per memorizzare dati (numerici, logici o caratteri) che possono variare
durante l'esecuzione del programma. Una variabile può contenere solo dati di specifico tipo indicato nella dichiarazione.

\subsubsection*{Dichiarazione, inizializzazione e assegnazione}
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] \textbf{dichiarazione}: \verb|int a;| \\
	viene riservato uno spazio in memoria in grado di contenere valori del tipo indicato al posto di \verb|tipo|
	\item[-] \textbf{inizializzazione}: \verb|int a = 0;| \\
	viene dichiara una variabile e le viene assegnato un valore inziale
	\item[-] \textbf{assegnazione}: \verb|a = 345;| \\
	viene salvato un valore in una variabile
\end{itemize}

\subsubsection*{Visibilità}
Le variabili vengono create al momento della loro dichiarazione e vengono distrutte alla chiusura del blocco in cui sono
state create. Inoltre sono accessibili solo all'intendo del blocco (e sottoblocchi) in cui sono state dichiarate.

\subsubsection*{Tipi di dato}
\begin{center}
	\begin{tabularx}{\textwidth}{c c c c X}
		\textbf{tipo} & \textbf{min} & \textbf{max} & \textbf{mem} & \textbf{descrizione} \\
		\toprule

		\textbf{byte}
		& -128 & 127 & 8 bit & rappr. di numeri interi in complemento a due \\
		\midrule
		
		\textbf{short}
		& -32 768 & 32 767 & 16 bit & rappr. di numeri interi in complemento a due \\
		\midrule

		\textbf{int}
		& \(-2,15 \cdot 10^9\) & \(2,15 \cdot 10^9\) & 32 bit & rappr. di numeri interi in complemento a due \\
		\midrule
		
		\textbf{long}
		& \(-9,22 \cdot 10^{18}\) & \(9,22 \cdot 10^{18}\) & 64 bit & rappr. di numeri interi in complemento a due \\
		\midrule
		
		\textbf{float}
		& \(1.18 \cdot 10^{-38}\) & \(3.40 \cdot 10^{38}\) & 32 bit & rappr. numeri decimali in singola precisione \\
		\midrule
		
		\textbf{double}
		& \(4.94 \cdot 10^{-324}\) & \(1.80 \cdot 10^{308}\) & 64 bit & rappr. numeri decimali in doppia precisione \\
		\midrule
		
		\textbf{char}
		& 0 & 65535 & 16 bit & rappr. numeri interi \(\geq 0\) per standard UNICODE \\
		\midrule

		\textbf{boolean}
		& false & true & 1 bit & rappr. di valori booleani true, false
	\end{tabularx}
\end{center}

\subsubsection*{Promozione e casting}
Per convertire un valore di un determinato tipo di dato in un altro, esistono due operazioni:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] \textbf{promozione}: \verb|double a = 123| \\
	sempre concesso e non genera errori, avviene quando si converte un numero con minore precisione in un formato con
	maggiore precisione
	\item[-] \textbf{casting}: \verb|int a = (int)123,45| \\
	se non correttamente gestito può generare errori di perdita di precisione o overflow, avviene quando si converte
	un numero con maggiore precisione in un formato con minore precisione, per eseguire il casting è necessario indicare
	tra parentesi il nuovo tipo di dato, davanti al valore da convertire
\end{itemize}

\subsubsection*{Oveflow}
L'overflow avviene 1uando si supera il valore massimo (o minimo) consentito da un determinato tipo di dato. Nei numeri
interi, i valori hanno comportamento "ciclico" quando si supera il valore superiore, si ricomincia dal valore inferiore 
e viceversa.

\subsubsection*{Operazioni}
\begin{center}
	\begin{tabularx}{\textwidth}{c c X}		
		\multirow{2}{*}{\textbf{somma}}
		& \verb|a + b| & viene eseguita la somma (possibile overflow) \\
		& \verb|a++| & al variabile viene incrementata di uno \\
		\midrule

		\multirow{2}{*}{\textbf{differenza}}
		& \verb|a - b| & viene eseguita la differenza \\
		& \verb|a--| & la variabile viene decrementata di uno \\
		\midrule
		
		\textbf{prodotto}
		& \verb|a * b| & viene eseguito il prodotto \\
		\midrule
		
		\textbf{divisione}
		& \verb|a / b| & viene eseguita la divisione, se entrambe le variabili sono di tipo int viene eseguita la divisione
		intera (tralasciando la parte decimale), se almeno una delle due è double, allora viene eseguita la divisione reale,
		se b è 0 e le variabili sono intere, viene lanciata una \verb|ArithmeticException| \\
		\midrule
		
		% non funziona il % in verb
		\textbf{modulo}
		& \verb|a| \% \verb|b| & calcola il resto della divisione tra a e b, se b è 0 e le variabili sono intere, viene
		lanciata una \verb|ArithmeticException| \\
		\midrule
		
		\multirow{3}{*}{\textbf{confronti}}
		& \verb|a == b| & \multirow{3}{*}{confronta il valore contenuto nelle due variabili} \\
		& \verb|a < b| \(\;\;\) \verb|a <= b| & \\
		& \verb|a > b| \(\;\;\) \verb|a >= b| & \\
		\midrule

		\textbf{and}
		& \verb|a && b| & restituisce \verb|true| se e solo se entrambi i membri sono \verb|true| \\
		\midrule

		% non funziona il || in verb
		\textbf{or}
		& \verb|a| \(||\) \verb|b| & restituisce \verb|true| se almeno uno dei due membri è \verb|true| \\
		\midrule

		\textbf{not}
		& \verb|!a| & restituisce \verb|true| se \verb|a| è \verb|false| e viceversa
	\end{tabularx}
\end{center}

\subsubsection*{Precedenze}
In ordine di precedenza:
\begin{enumerate}[topsep=3pt, itemsep=0pt]
	\item operatori unari: di incremento e decremento, not logico, byteshift, \dots
	\item prodotto, divisione e modulo
	\item somma e sottrazione
	\item confronti con uguaglianza
	\item operatore logico and
	\item operatore logico or
	\item assegnazioni
\end{enumerate}

\subsubsection*{Costanti}
Le costanti sono un tipo particlare di variabili che contengono un valore fisso per tutta la durata dell'esecuzione.
il valore è assegnato al momento della dichiarazione. In genere le costanti si indicano con lettere maiuscole.
\verb|final double PI = 3,14...|

\subsubsection*{Literals}
I Literals sono l'insieme di numeri e stringhe che vengono utilizzate nel programma e che non sono contenuti in una variabile.
Ad esempio i valori di inizializzazione delle variabili o i messaggi di testo da mandare in output.

I numeri interi vengono interpretati di tipo \verb|int|, quelli decimali come \verb|double|, i caratteri racchiusi da singoli
apici es. \verb|'c'| come \verb|char| e le sequenze di caratteri racchiuse tra doppi apici \verb|"text"| come oggetti della
classe String.

\newpage


\subsection{Metodi}
I metodi sono blocchi di codice racchiusi da parentesi graffe che contengono istruzioni che risolvono un determinato problema.
Un programma eseguibile deve necessariamente avere un metodo main defininto come \verb|public static void main(String[] args) { }|.

\subsubsection*{Struttura}
\begin{lstlisting}[language=Java]
tipoRestituito nomeMetodo (parametriFormali) {
	istruzioni;
	return valoreRestituito;
}
\end{lstlisting}

La prima riga del metodo viene chiamata firma

Un metodo può ricevere in input dei parametri espliciti indicati tra le parentesi tonde e restituire in output un valore di ritorno
il cui tipo è specicificato prima del nome del metodo e il valore viene indicato alla fine del metodo dopo la parola return.
Se un metodo non restituisce nessun valore si utilizza \verb|void| al posto del tipoRestituito e il return viene omesso o 
indicato senza specificare il valoreRestituito.

\subsubsection*{Overloading}
\dots


\subsection{Classi e oggetti}
Una classe è un contenitore di metodi e variabili. Sono alla base del paradigma di programmazione ad oggetti (OOP) e permettono
un maggiore livello di astrazione per risolvere problemi complessi più facilmente.

Ogni file Java deve contenere una classe pubblica con lo stesso nome del file. Questa classe può essere eseguibile se ha un metodo
main, altrimenti viene detta non eseguibile.

Una classe può essere istanziabile, ovvero è possibile crearne delle copie (più o meno indipendenti) che prendono il nome di oggetti
o istanze della classe.

\subsubsection*{Struttura}
Una classe è composta da:
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		\textbf{variabili d'istanza} & memorizzano le informazioni e lo stato di un oggetto \\
		\midrule
		\textbf{metodi costruttori} & contengono le istruzioni da eseguire alla creazione dell'oggetto, es. inizializzazione delle variabili \\
		\midrule
		\textbf{metodi di accesso} & servono per accedere alle variabili d'istanza, senza poterle modificare \\
		\midrule
		\textbf{metodi modificatori} & servono per modificare le variabili d'istanza secondo dei precisi criteri
	\end{tabularx}
\end{center}

\subsubsection*{Incapsulamento}
Per evitare che l'oggetto venga messo in uno stato non valido (es. lati di una figura negativi), si sceglie di nascondere le variabili
d'istanza, riducendone l'accessibilità, e creando dei metodi di accesso e di modifica. Questo principio di "nascondere" le variabili è chiamato incapsulamento e prevede i seguenti vantaggi:
\begin{itemize}[topsep=3pt, itemsep=0pt]
	\item[-] impedire che l'oggetto venga messo in uno stato inconsistente
	\item[-] l'utilizzatore non deve preoccuparsi dei dettagli implementativi
	\item[-] se si modifica l'implementazione di un metodo, non serve modificarne i programmi in cui è impiegato
	\item[-] se c'è un errore nelle variabili d'istanza, va cercato nei metodi della classse o nelle loro invocazioni
\end{itemize}

\subsubsection*{Accessibilità}
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		public & accessibile da qualsiasi classe \\
		\midrule
		package & (default) accessibile da qualsiasi classe contenuta nello stesso pacchetto \\
		\midrule
		protected & accessibile da qualsiasi sottoclasse della classe in cui è creato \\
		\midrule
		private & accessibile solo dalla classe in cui è stato creato
	\end{tabularx}
\end{center}

\subsubsection*{Struttura base di una classe generatrice di oggetti}
\begin{lstlisting}[language=Java]
class NomeClasse {
	// variabili d'istanza
	private int variabileIstanza1;
	...

	// costruttore
	public NomeClasse() {
		variabileIstanza1 = 0;
		...
	}

	// metodi di accesso
	public getVariabileIstanza1(){
		return variabileIstanza1;
	}
	...

	// metodi di modifica
	public setVariabileIstanza1(int v1) {
		variabileIstanza1 = v1;
	}
	...
}
\end{lstlisting}

\subsubsection*{Instanziamento di un oggetto e richiamo metodi}
\begin{lstlisting}[language=Java]
// istanziamento di un oggetto della classe NomeClasse
NomeClasse nomeOggetto = new NomeClasse(parametri);

// invocazione del metodo metodo1 dall'oggetto nomeOggetto
nomeOggetto.metodo1(parametri);
\end{lstlisting}

\subsubsection*{Variabili statiche e non statiche}
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		static & variabile unica comune a tutte le istanze di una classe, se viene modificata da un'istanza, si modifica per
		tutte le istanze \\
		\midrule
		non-static & variabile propria di una specifica istanza, indipendente dalla corrispettiva in istanze diverse
	\end{tabularx}
\end{center}

\subsubsection*{Metodi statici e non statici}
\begin{center}
	\begin{tabularx}{\textwidth}{c X}
		static & non può accedere alle variabili d'istanza e non ha parametri impliciti, si invoca indicando
		\verb|NomeClasse.nomeMetodo(parametri espliciti)| \\
		\midrule
		non-static & può accedere alle variabili d'istanza e ha come parametro implicito l'oggetto invocante
		si invoca indicando \verb|nomeOggetto.nomeMetodo(parametri espliciti)|
	\end{tabularx}
\end{center}

\subsubsection*{Riferimenti ad oggetti}
Quando si dichiara un nuovo oggetto, si crea uno spazio in memoria in cui vengono salvati i dati dell'oggetto (es. variabili
d'istanza e metodi) e viene creata una variabile riferimento che punta alla posizione in memoria dell'oggetto.

Per cui se creo un oggetto \verb|A a = A();| e uno \verb|A b = a;|, le modifiche che faccio ad \verb|a| si riflettono anche
su \verb|b| in quanto entrambi \verb|a| e \verb|b| puntano alla stessa posizione in memoria, per cui allo stesso oggetto.

Quando viene passato un oggetto ad un metodo come parametro esplicito, le modifiche che vengono fatte all'oggetto all'interno
del metodo, si riscontrano anche sull'oggetto nel metodo chiamante.

\subsubsection*{Ereditarietà e polimorfismo}
\dots

\subsubsection*{Pacchetti e organizzazione}
Più classi che svolgono compiti simili vengono raggiuppatte in pacchetti. Es. pacchetto \verb|java.lang| racchiude la classe
\verb|System|, la classe \verb|String| e la classe \verb|Math|.

Per utilizzare delle classi che si trovano in file diversi in cartelle diverse, bisogna inserire all'inizio del programma
(fuori dalla classe) la parola chiave import seguita dal pacchetto che si vuole importare. Il pacchetto \verb|java.lang|
è importato di default su ogni progetto.

\subsection{Classe java.lang.String}
utilizzo, metodi, \dots

\subsection{Classe java.util.Scanner}
utilizzo, metodi, \dots

\subsection{Classe java.io.FileReader}
utilizzo, metodi, \dots

\subsection{Classe java.io.PrintWriter}
utilizzo, metodi, \dots

\subsection{Classe java.util.Random}
utilizzo, metodi, \dots

\subsection{Commenti e JavaDoc}
I commenti sono parti di testo che il compilatore ignora. Si usano per descrivere quali operazioni vengono effettuate
in una determinata parte del codice. Possono essere su una singola riga \verb|\\ commento| o su più righe \verb|/* commento */|.

Esiste uno standard di commentazione che permette di creare una documentazione nello stesso stile di quella di java,
con il  comando \verb|javadoc NomeFile.java|.Si prevede un commento su più righe posto prima di un metodo o una classe
e in tale commento vengono descritti la funzione della classe, i parametri (preceduti da \verb|@param|), il valore di
ritorno (preceduto da \verb|@return|) ed eventuali eccezioni che possono essere lanciate.

\begin{lstlisting}[language=Java]
/**
 * Descrizione del metodo
 * 
 * @param p1 parametro 1
 * @param p2 parametro 2
 * @return valore che viene restituito
 */
public int metodo(int p1, double p2) { ...
\end{lstlisting}

% --------------------------------------- Strutture logiche ---------------------------------------
\subsection{Operazioni logiche}
\subsubsection*{Operazioni logiche}
\dots

\subsubsection*{Confronti tra double / float}
\dots

\subsubsection*{Confronti tra oggetti}
\dots

\subsubsection*{De Morgan}
\dots

\subsubsection*{Cortocircuito logico}
\dots

\subsection{Selezioni}
utilizzo, struttura, else if, annidamento, else sospeso, espressioni logiche, \dots
switch case

\subsection{Iterazioni}
while, do-while, for, cicli annidati, break, continue


% ---------------------------------- Note sulla memoria in Java -----------------------------------
\subsection{Note sulla memoria in Java}
\subsubsection*{Heap e Stack}
\dots

\subsubsection*{Record di attivazione}
\dots

% ------------------------------ Reindirizzamento del flusso di i/o -------------------------------
\subsection{Reindirizzamento dei flussi i/o}
\subsubsection*{Reindirizzamento del flusso di input}
\dots

\subsubsection*{Reindirizzamento del flusso di ouput}
\dots

\subsubsection*{Canalizzazioni o pipes}
\dots

% -------------------------------------- Eccezioni ed errori --------------------------------------
\subsection{Eccezioni in Java}
\subsubsection*{generale...}
\dots

\subsubsection*{Throw}
\dots

\subsubsection*{Try - catch}
\dots

\subsubsection*{Try with resources}
\dots

\subsubsection*{Eccezioni checked e unchecked}
\dots

% ------------------------------------------ Ricorsione -------------------------------------------
\section{Ricorsione}
\dots

% ---------------------------------- Complessità computazionale -----------------------------------
\section{Complessità computazionale}
\dots

\subsection{Complessità temporale}
\dots

\subsection{Complessità spaziale}
\dots

% ---------------------------------------- Strutture dati -----------------------------------------
\section{Strutture dati}
adt, liste e array

\subsection{Array}
definione, struttura, creazione, passaggio come parametro

\subsubsection*{Algoritmo di copia}
copia di un array

\subsubsection*{Algoritmo di ridimensionamento}
ridimensionamento di un array

\subsubsection*{Array riempiti a metà}
dimensione logica vs dimensione relative

\subsection{Matrici}
array bidimensionali

% ----------------------------------- Algoritmi di ordinamento ------------------------------------
\section{Algoritmi di ordinamento}
\dots

\subsection{SelectionSort}
\dots

\subsection{MergeSort}
\dots

\subsection{InsertionSort}
\dots

\subsection{Confronto complessità}
\dots

% ------------------------------------- Algoritmi di ricerca --------------------------------------
\section{Algoritmi di ricerca}
\dots

\subsection{Ricerca lineare}
\dots

\subsection{Ricerca binaria}
\dots

\end{document}